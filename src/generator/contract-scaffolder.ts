/**
 * Contract Library Scaffolding
 *
 * Scaffolds contract libraries for detected domains.
 * Uses monorepo-library-generator if available, falls back to manual scaffolding.
 * Uses Effect Schema for strict validation.
 */

import { execSync } from 'node:child_process';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { Schema } from 'effect';
import type { GeneratorConfig } from './config.js';
import type { DomainInfo } from './domain-detector.js';

/**
 * Scaffold method schema
 */
const ScaffoldMethod = Schema.Literal('generator', 'manual', 'existing');

/**
 * Scaffold result schema
 */
const ScaffoldResultSchema = Schema.Struct({
  domain: Schema.String,
  outputPath: Schema.String,
  scaffolded: Schema.Boolean,
  method: ScaffoldMethod,
  error: Schema.optional(Schema.String),
});

/**
 * Scaffold result type derived from schema
 */
export type ScaffoldResult = Schema.Schema.Type<typeof ScaffoldResultSchema>;

/**
 * Create a validated scaffold result
 */
const createResult = Schema.decodeUnknownSync(ScaffoldResultSchema);

/**
 * Scaffold contract libraries for all domains
 *
 * For each domain:
 * 1. Check if contract library already exists
 * 2. Use monorepo-library-generator if available and configured
 * 3. Fall back to manual scaffolding if generator not available
 */
export async function scaffoldContractLibraries(domains: DomainInfo[], config: GeneratorConfig) {
  const results: ScaffoldResult[] = [];

  for (const domain of domains) {
    try {
      const result = await scaffoldDomainLibrary(domain, config);
      results.push(result);
    } catch (error) {
      results.push(
        createResult({
          domain: domain.name,
          outputPath: '',
          scaffolded: false,
          method: 'manual',
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  return results;
}

/**
 * Scaffold a contract library for a single domain
 */
async function scaffoldDomainLibrary(domain: DomainInfo, config: GeneratorConfig) {
  const outputPath = getContractOutputPath(config.output, domain.name);

  // Check if library already exists
  if (fs.existsSync(outputPath)) {
    return createResult({
      domain: domain.name,
      outputPath,
      scaffolded: false,
      method: 'existing',
    });
  }

  // Try using monorepo-library-generator
  if (config.libraryGenerator) {
    const generatorResult = await tryGeneratorScaffold(domain, config);
    if (generatorResult) {
      return generatorResult;
    }
  }

  // Fall back to manual scaffolding
  return manualScaffold(domain, config);
}

/**
 * Try scaffolding using monorepo-library-generator
 */
function tryGeneratorScaffold(domain: DomainInfo, config: GeneratorConfig) {
  const generatorPath = config.libraryGenerator;
  if (!generatorPath) {
    return null;
  }

  try {
    // Check if generator exists
    if (!fs.existsSync(generatorPath)) {
      return null;
    }

    // Use the contract generator from monorepo-library-generator
    const command = `node ${generatorPath}/dist/cli/index.js generate contract ${domain.name} --description "Contract library for ${domain.name} domain (generated by prisma-effect-kysely)"`;
    execSync(command, { stdio: 'inherit' });

    const outputPath = getContractOutputPath(config.output, domain.name);

    return createResult({
      domain: domain.name,
      outputPath,
      scaffolded: true,
      method: 'generator',
    });
  } catch {
    return null;
  }
}

/**
 * Manual scaffolding fallback
 *
 * Creates minimal contract library structure:
 * - package.json
 * - tsconfig.json
 * - src/index.ts
 * - src/generated/ (for Prisma-generated schemas)
 */
function manualScaffold(domain: DomainInfo, config: GeneratorConfig) {
  const outputPath = getContractOutputPath(config.output, domain.name);

  // Create directory structure
  fs.mkdirSync(path.join(outputPath, 'src', 'generated'), { recursive: true });

  // Create package.json
  const packageJson = {
    name: `@proj/contract-${domain.name}`,
    version: '0.0.1',
    type: 'module',
    main: './src/index.ts',
    exports: {
      '.': {
        import: './src/index.ts',
        types: './src/index.ts',
      },
    },
    dependencies: {},
    peerDependencies: {
      effect: '^3.0.0',
      kysely: '^0.28.0',
    },
  };

  fs.writeFileSync(path.join(outputPath, 'package.json'), JSON.stringify(packageJson, null, 2));

  // Create tsconfig.json
  const tsConfig = {
    extends: '../../../tsconfig.base.json',
    compilerOptions: {
      outDir: `../../../dist/libs/contract/${domain.name}`,
      composite: true,
      declaration: true,
      declarationMap: true,
    },
    include: ['src/**/*.ts'],
    exclude: ['node_modules', 'dist', '**/*.spec.ts'],
  };

  fs.writeFileSync(path.join(outputPath, 'tsconfig.json'), JSON.stringify(tsConfig, null, 2));

  // Create src/index.ts
  const indexContent = `/**
 * ${domain.name.charAt(0).toUpperCase() + domain.name.slice(1)} Domain Contract
 *
 * Generated by prisma-effect-kysely
 * This file re-exports generated schemas from the generated/ directory.
 */

export * from './generated.js';
`;

  fs.writeFileSync(path.join(outputPath, 'src', 'index.ts'), indexContent);

  // Create .gitkeep in generated directory
  fs.writeFileSync(path.join(outputPath, 'src', 'generated', '.gitkeep'), '');

  return createResult({
    domain: domain.name,
    outputPath,
    scaffolded: true,
    method: 'manual',
  });
}

/**
 * Get output path for a domain's contract library
 *
 * @example
 * getContractOutputPath("../libs/contract", "user")
 * // => "../libs/contract/user"
 */
function getContractOutputPath(baseOutput: string, domainName: string) {
  return path.join(baseOutput, domainName);
}

/**
 * Log scaffolding results
 */
export function logScaffoldResults(results: ScaffoldResult[]) {
  for (const result of results) {
    const _status = result.scaffolded ? '✓' : result.error ? '✗' : '○';
    const _method =
      result.method === 'generator'
        ? '(generator)'
        : result.method === 'manual'
          ? '(manual)'
          : '(existing)';

    if (result.error) {
      // Error handling would go here if needed
    }
  }
}
