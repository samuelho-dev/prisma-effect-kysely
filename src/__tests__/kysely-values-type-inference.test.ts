/**
 * Kysely .values() Type Inference Test
 *
 * This test demonstrates the type mismatch when using Kysely's .values() method
 * with schemas generated by prisma-effect-kysely.
 *
 * PROBLEM:
 * When calling `db.insertInto('user').values(input)`, Kysely extracts types from
 * `DB['user']`. If `DB['user']` uses `Selectable<User>` wrapper, Kysely doesn't
 * properly recognize our ColumnType and Generated wrappers, requiring `as never` casts.
 *
 * ROOT CAUSE:
 * 1. DB interface currently wraps tables with Selectable<>
 * 2. Selectable<> strips the __select__, __insert__, __update__ phantom properties
 * 3. Kysely's InsertType<T> falls back to treating all fields as required
 *
 * EXPECTED BEHAVIOR:
 * - `columnType(T, never, never)` fields should be EXCLUDED from insert
 * - `generated(T)` fields should be OPTIONAL on insert
 * - Regular fields should be REQUIRED on insert
 */

import { Schema } from 'effect';
import { describe, it, expectTypeOf } from 'vitest';
import type { InsertObject } from 'kysely';
import {
  columnType,
  generated,
  Selectable as PekSelectable,
  Insertable as PekInsertable,
  ColumnType,
  Generated,
} from '../kysely/helpers';

// =============================================================================
// Test Schema Definition
// =============================================================================

const UserId = Schema.String.pipe(Schema.brand('UserId'));
type UserId = typeof UserId.Type;

const User = Schema.Struct({
  id: columnType(UserId, Schema.Never, Schema.Never), // Read-only ID
  email: Schema.String, // Required field
  name: Schema.NullOr(Schema.String), // Nullable field
  createdAt: generated(Schema.DateFromSelf), // Generated field (optional on insert)
  updatedAt: generated(Schema.DateFromSelf), // Generated field (optional on insert)
});
type User = typeof User;

// =============================================================================
// DB Interface Patterns
// =============================================================================

// CURRENT: DB interface wraps with Selectable<> - THIS BREAKS KYSELY TYPE EXTRACTION
interface DBWithSelectable {
  user: PekSelectable<User>;
}

// PROPOSED FIX: DB interface uses raw schema type - PRESERVES PHANTOM PROPERTIES
type UserSchemaType = Schema.Schema.Type<User>;
interface DBWithoutSelectable {
  user: UserSchemaType;
}

// =============================================================================
// Type Extraction Helpers (mimicking Kysely's internals)
// =============================================================================

/**
 * Kysely's InsertType extraction pattern (simplified)
 * If T has __insert__, use that. Otherwise, use T as-is.
 */
type KyselyInsertType<T> = T extends { readonly __insert__: infer I } ? I : T;

/**
 * Extract insert types for all fields in a table
 */
type ExtractInsertTypes<T> = {
  [K in keyof T]: KyselyInsertType<T[K]>;
};

// =============================================================================
// Tests
// =============================================================================

describe('Kysely .values() Type Inference Issue', () => {
  describe('prisma-effect-kysely Insertable<> works correctly', () => {
    it('should correctly compute insert types', () => {
      type UserInsert = PekInsertable<User>;

      // id should be excluded (never insert type)
      expectTypeOf<UserInsert>().not.toHaveProperty('id');

      // email should be required
      expectTypeOf<UserInsert>().toHaveProperty('email');

      // createdAt/updatedAt should be optional (generated)
      // Verify createdAt is present (it's optional, so we just check it exists)
      expectTypeOf<UserInsert>().toHaveProperty('createdAt');
    });
  });

  describe('DBWithSelectable breaks Kysely type extraction', () => {
    it('should demonstrate that Selectable<> strips phantom properties', () => {
      type UserFromDB = DBWithSelectable['user'];

      // After Selectable<>, the __insert__ property is stripped
      // This is because Selectable() returns StripKyselyWrappersFromObject<T>
      // which removes the ColumnType/Generated wrappers

      // Check if __insert__ exists on the id field
      type IdField = UserFromDB extends { id: infer T } ? T : never;

      // The id field should be a plain string (UserId brand), NOT ColumnType
      // This means Kysely can't detect that it should be excluded from INSERT
      expectTypeOf<IdField>().toBeString();

      // Verify __insert__ is NOT present (this is the problem!)
      type HasInsertPhantom = IdField extends { readonly __insert__: unknown } ? true : false;
      expectTypeOf<HasInsertPhantom>().toEqualTypeOf<false>();
    });

    it('should show Kysely would require all fields for insert', () => {
      type UserFromDB = DBWithSelectable['user'];
      type InsertTypes = ExtractInsertTypes<UserFromDB>;

      // With Selectable<>, Kysely extracts field types WITHOUT __insert__
      // So it falls back to treating all fields as their base types (required)

      // id would be treated as required string (WRONG - should be excluded)
      type IdInsertType = InsertTypes['id'];
      expectTypeOf<IdInsertType>().toBeString();

      // createdAt would be treated as required Date (WRONG - should be optional)
      type CreatedAtInsertType = InsertTypes['createdAt'];
      expectTypeOf<CreatedAtInsertType>().toEqualTypeOf<Date>();
    });
  });

  describe('DBWithoutSelectable preserves phantom properties', () => {
    it('should preserve __insert__ phantom property on ColumnType fields', () => {
      type UserFromDB = DBWithoutSelectable['user'];

      // Check the id field type
      type IdField = UserFromDB['id'];

      // The id field should be ColumnType<UserId, never, never>
      // which has __insert__: never
      type HasInsertPhantom = IdField extends { readonly __insert__: infer I } ? I : 'no-phantom';

      // __insert__ should be `never` for read-only ID fields
      expectTypeOf<HasInsertPhantom>().toBeNever();
    });

    it('should preserve __insert__ phantom property on Generated fields', () => {
      type UserFromDB = DBWithoutSelectable['user'];

      // Check the createdAt field type
      type CreatedAtField = UserFromDB['createdAt'];

      // The createdAt field should be Generated<Date>
      // which has __insert__: Date | undefined
      type InsertType = CreatedAtField extends { readonly __insert__: infer I } ? I : 'no-phantom';

      // __insert__ should be `Date | undefined` for generated fields
      expectTypeOf<InsertType>().toEqualTypeOf<Date | undefined>();
    });

    it('should allow Kysely to correctly extract insert types', () => {
      type UserFromDB = DBWithoutSelectable['user'];
      type InsertTypes = ExtractInsertTypes<UserFromDB>;

      // id should extract to `never` (excluded from insert)
      type IdInsertType = InsertTypes['id'];
      expectTypeOf<IdInsertType>().toBeNever();

      // createdAt should extract to `Date | undefined` (optional on insert)
      type CreatedAtInsertType = InsertTypes['createdAt'];
      expectTypeOf<CreatedAtInsertType>().toEqualTypeOf<Date | undefined>();

      // email should remain as string (required)
      type EmailInsertType = InsertTypes['email'];
      expectTypeOf<EmailInsertType>().toBeString();
    });
  });

  describe('Real Kysely InsertExpression compatibility', () => {
    // This test demonstrates the actual Kysely type extraction behavior

    it('should show InsertObject type difference', () => {
      // With Selectable wrapper (current - broken)
      type InsertWithSelectable = InsertObject<DBWithSelectable, 'user'>;

      // Without Selectable wrapper (proposed fix)
      type InsertWithoutSelectable = InsertObject<DBWithoutSelectable, 'user'>;

      // The key difference:
      // - InsertWithSelectable requires ALL fields (id, email, createdAt, etc.)
      // - InsertWithoutSelectable correctly:
      //   - Excludes `id` (because __insert__ is never)
      //   - Makes `createdAt`/`updatedAt` optional (because __insert__ is T | undefined)
      //   - Requires `email` and `name`

      // Verify InsertWithoutSelectable doesn't have id
      expectTypeOf<InsertWithoutSelectable>().not.toHaveProperty('id');

      // InsertWithSelectable DOES have id (this is the bug!)
      // This demonstrates the problem - Kysely requires id for insert when using Selectable<>
      expectTypeOf<InsertWithSelectable>().toHaveProperty('id');
    });

    it('should demonstrate the as never workaround need', () => {
      // This is what developers currently have to write:
      //
      // const input: PekInsertable<User> = { email: 'test@example.com' };
      // db.insertInto('user').values(input as never);
      //
      // The `as never` is needed because:
      // - PekInsertable<User> correctly computes { email: string; createdAt?: Date; ... }
      // - But Kysely's InsertExpression<DBWithSelectable, 'user'> expects all fields
      // - These types don't match, so TypeScript errors without the cast

      type PekInsert = PekInsertable<User>;
      type KyselyInsert = InsertObject<DBWithSelectable, 'user'>;

      // These should be assignable if types matched, but they don't
      // PekInsert is missing `id`, but KyselyInsert requires it
      type PekHasId = 'id' extends keyof PekInsert ? true : false;
      type KyselyHasId = 'id' extends keyof KyselyInsert ? true : false;

      expectTypeOf<PekHasId>().toEqualTypeOf<false>(); // Correct: id excluded
      expectTypeOf<KyselyHasId>().toEqualTypeOf<true>(); // Bug: id required
    });

    it('should work without cast after fix', () => {
      // After the fix, this should work:
      //
      // const input: PekInsertable<User> = { email: 'test@example.com' };
      // db.insertInto('user').values(input);  // No cast needed!

      type PekInsert = PekInsertable<User>;
      type KyselyInsertFixed = InsertObject<DBWithoutSelectable, 'user'>;

      // Both should exclude `id`
      type PekHasId = 'id' extends keyof PekInsert ? true : false;
      type KyselyHasId = 'id' extends keyof KyselyInsertFixed ? true : false;

      expectTypeOf<PekHasId>().toEqualTypeOf<false>();
      expectTypeOf<KyselyHasId>().toEqualTypeOf<false>();
    });
  });
});

describe('Generated<T> needs __select__ for Kysely compatibility', () => {
  /**
   * This test verifies that Generated<T> includes __select__ phantom property.
   *
   * Kysely's InsertType extraction pattern:
   * ```
   * type InsertType<T> = T extends ColumnType<any, infer I, any> ? I : T;
   * ```
   *
   * The ColumnType pattern check requires:
   * - __select__: S
   * - __insert__: I
   * - __update__: U
   *
   * If __select__ is missing, Kysely falls back to treating the field as `T` (required).
   */

  it('should have __select__ on Generated type', () => {
    type GeneratedDate = Generated<Date>;

    type HasSelect = GeneratedDate extends { readonly __select__: infer S } ? S : 'no-select';

    // Generated<Date> should have __select__: Date
    expectTypeOf<HasSelect>().toEqualTypeOf<Date>();
  });

  it('should have all three phantom properties for Kysely compatibility', () => {
    type GeneratedDate = Generated<Date>;

    // Check all three phantom properties that Kysely expects
    type SelectType = GeneratedDate extends { readonly __select__: infer S } ? S : never;
    type InsertType = GeneratedDate extends { readonly __insert__: infer I } ? I : never;
    type UpdateType = GeneratedDate extends { readonly __update__: infer U } ? U : never;

    expectTypeOf<SelectType>().toEqualTypeOf<Date>();
    expectTypeOf<InsertType>().toEqualTypeOf<Date | undefined>();
    expectTypeOf<UpdateType>().toEqualTypeOf<Date>();
  });

  it('should have all three phantom properties on ColumnType', () => {
    type IdColumnType = ColumnType<string, never, never>;

    type SelectType = IdColumnType extends { readonly __select__: infer S } ? S : never;
    type InsertType = IdColumnType extends { readonly __insert__: infer I } ? I : never;
    type UpdateType = IdColumnType extends { readonly __update__: infer U } ? U : never;

    expectTypeOf<SelectType>().toBeString();
    expectTypeOf<InsertType>().toBeNever();
    expectTypeOf<UpdateType>().toBeNever();
  });
});
